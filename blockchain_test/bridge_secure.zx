// Bridge Contract - SECURE VERSION
// Enables cross-chain token transfers with proper validation

export contract BridgeSecure {
    data name = "TokenBridge"
    data source_chain = "ChainA"
    data target_chain = "ChainB"
    data locked_tokens = {}  // address -> amount (locked on source chain)
    data minted_tokens = {}  // address -> amount (minted on target chain)
    data bridge_transactions = []
    data bridge_fee = 10  // Fee in basis points (0.1%)
    data owner = ""
    
    action setup(source, target) {
        source_chain = source
        target_chain = target
        owner = msg["sender"]
        
        print("[BRIDGE] Initialized: " + string(source) + " <-> " + string(target))
        print("[BRIDGE] Owner: " + string(owner))
        
        return {
            "success": true,
            "source": source,
            "target": target,
            "owner": owner
        }
    }
    
    action lock_and_bridge(token_contract, from_wallet, to_address, amount) {
        print("[BRIDGE] Initiating bridge transfer...")
        print("[BRIDGE] From: " + string(from_wallet) + " (Chain: " + string(source_chain) + ")")
        print("[BRIDGE] To: " + string(to_address) + " (Chain: " + string(target_chain) + ")")
        print("[BRIDGE] Amount: " + string(amount))
        
        // SECURITY FIX #1: Validate sender authorization
        let sender = msg["sender"]
        require(sender == from_wallet, "Not authorized to bridge from this wallet")
        
        // SECURITY FIX #2: Validate amount
        require(amount > 0, "Amount must be positive")
        
        // SECURITY FIX #3: Validate addresses
        require(from_wallet != "", "From wallet address cannot be empty")
        require(to_address != "", "To address cannot be empty")
        require(len(from_wallet) >= 6, "From wallet address too short")
        require(len(to_address) >= 6, "To address too short")
        
        // SECURITY FIX #4: Verify sufficient balance BEFORE attempting transfer
        let from_balance = token_contract.balance_of(from_wallet)
        require(from_balance >= amount, "Insufficient balance for bridge transfer")
        
        // Calculate fee
        let fee = (amount * bridge_fee) / 10000
        let amount_after_fee = amount - fee
        
        // SECURITY FIX #5: Validate fee calculation doesn't overflow
        require(amount_after_fee > 0, "Amount too small after fees")
        
        print("[BRIDGE] Bridge fee: " + string(fee) + " (" + string(bridge_fee / 100) + "%)")
        print("[BRIDGE] Amount after fee: " + string(amount_after_fee))
        
        // Lock tokens on source chain
        let bridge_address = "0xBRIDGE"
        let lock_result = token_contract.transfer(from_wallet, bridge_address, amount)
        
        // SECURITY FIX #6: Verify lock succeeded before minting
        require(lock_result["success"], "Failed to lock tokens: " + string(lock_result["error"]))
        
        // Update locked tokens
        let current_locked = locked_tokens[from_wallet]
        if current_locked == null {
            current_locked = 0
        }
        locked_tokens[from_wallet] = current_locked + amount
        
        // Simulate minting on target chain (in real bridge, this would be separate)
        let current_minted = minted_tokens[to_address]
        if current_minted == null {
            current_minted = 0
        }
        minted_tokens[to_address] = current_minted + amount_after_fee
        
        // Record bridge transaction
        let bridge_tx = {
            "from_wallet": from_wallet,
            "to_address": to_address,
            "amount": amount,
            "fee": fee,
            "amount_after_fee": amount_after_fee,
            "source_chain": source_chain,
            "target_chain": target_chain,
            "tx_hash": "0xBRIDGE_" + string(len(bridge_transactions)),
            "sender": sender
        }
        
        bridge_transactions = bridge_transactions + [bridge_tx]
        
        print("[BRIDGE] âœ… Bridge transfer completed")
        print("[BRIDGE] Transaction hash: " + string(bridge_tx["tx_hash"]))
        
        return {
            "success": true,
            "bridge_tx": bridge_tx
        }
    }
    
    action get_locked_balance(address) {
        let balance = locked_tokens[address]
        if balance == null {
            return 0
        }
        return balance
    }
    
    action get_minted_balance(address) {
        let balance = minted_tokens[address]
        if balance == null {
            return 0
        }
        return balance
    }
    
    action get_bridge_history() {
        return bridge_transactions
    }
    
    action get_stats() {
        let total_locked = 0
        let total_minted = 0
        let total_fees = 0
        
        // Calculate totals from bridge transactions
        let i = 0
        while i < len(bridge_transactions) {
            let tx = bridge_transactions[i]
            total_fees = total_fees + tx["fee"]
            i = i + 1
        }
        
        return {
            "name": name,
            "source_chain": source_chain,
            "target_chain": target_chain,
            "total_bridges": len(bridge_transactions),
            "total_fees_collected": total_fees,
            "bridge_fee_bp": bridge_fee,
            "owner": owner
        }
    }
}
