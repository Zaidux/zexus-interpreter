// REENTRANCY ATTACK TEST
// Attempts to exploit recursive calling vulnerability

print("=" * 100)
print("SECURITY TEST: Reentrancy Attack")
print("=" * 100)
print("")

// Vulnerable contract (if not protected)
contract VulnerableVault {
    data balances = {}
    data reentrancy_guard = false
    
    action initialize() {
        balances = {}
        reentrancy_guard = false
    }
    
    action deposit(address, amount) {
        let current = balances[address]
        if current == null {
            current = 0
        }
        balances[address] = current + amount
        print("‚úÖ Deposited " + string(amount) + " for " + address)
    }
    
    action withdraw(address, amount) {
        // SECURITY: Reentrancy guard
        require(reentrancy_guard == false, "Reentrancy detected!")
        reentrancy_guard = true
        
        let balance = balances[address]
        if balance == null {
            balance = 0
        }
        
        require(balance >= amount, "Insufficient balance")
        
        // VULNERABLE: External call before state update
        // In production, this would call the recipient's contract
        // which could call withdraw() again
        
        // Update state AFTER call (WRONG - should be before)
        balances[address] = balance - amount
        
        // SECURITY: Release guard
        reentrancy_guard = false
        
        print("‚úÖ Withdrawn " + string(amount) + " for " + address)
    }
    
    action get_balance(address) {
        let balance = balances[address]
        if balance == null {
            return 0
        }
        return balance
    }
}

// Attacker contract
contract ReentrancyAttacker {
    data target = null
    data attack_amount = 0
    data attack_count = 0
    data max_depth = 3
    
    action initialize(target_contract, amount) {
        target = target_contract
        attack_amount = amount
        attack_count = 0
    }
    
    action attack() {
        print("\nüî¥ STARTING REENTRANCY ATTACK...")
        print("Attempting to drain vault through recursive calls")
        
        // Initial deposit
        target.deposit("ATTACKER", attack_amount)
        
        // Try to withdraw recursively
        attack_count = 0
        this.recursive_withdraw()
        
        let final_balance = target.get_balance("ATTACKER")
        print("\nüìä Attack Results:")
        print("  Recursive calls attempted: " + string(attack_count))
        print("  Final attacker balance: " + string(final_balance))
        
        if attack_count > 1 {
            print("‚ùå VULNERABILITY: Reentrancy attack succeeded!")
            return false
        } else {
            print("‚úÖ PROTECTED: Reentrancy attack prevented")
            return true
        }
    }
    
    action recursive_withdraw() {
        if attack_count >= max_depth {
            return
        }
        
        attack_count = attack_count + 1
        print("  Recursive call #" + string(attack_count))
        
        // This would normally trigger another withdraw
        // target.withdraw("ATTACKER", attack_amount)
        // which would call this function again
    }
}

// ==================== TEST EXECUTION ====================

print("Setting up vulnerable vault...")
let vault = VulnerableVault()
vault.initialize()

// Give vault some initial balance
vault.deposit("VICTIM", 1000)

print("\nVault initialized:")
print("  Victim balance: " + string(vault.get_balance("VICTIM")))

print("\n" + "-" * 100)

// Setup attacker
let attacker = ReentrancyAttacker()
attacker.initialize(vault, 100)

// Execute attack
let is_protected = attacker.attack()

print("\n" + "=" * 100)
if is_protected {
    print("REENTRANCY TEST: ‚úÖ PASSED - System is protected")
} else {
    print("REENTRANCY TEST: ‚ùå FAILED - Vulnerability detected")
}
print("=" * 100)
