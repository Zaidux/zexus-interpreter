// Zexus performance benchmark: 10k transactions sequential vs bulk

use "./full_network_chain/full_network_blockchain.zx"
use {enable_vm, set_vm_thresholds, set_vm_config, profile_start, profile_stop, profile_report, vm_stats} from "stdlib/perf"
use {stringify} from "stdlib/json"

const PERF_TRANSACTION_COUNT = 200

const PERF_GENESIS = [
    {"address": "VAL_ALPHA", "balance": 5000000},
    {"address": "VAL_BETA", "balance": 5000000},
    {"address": "VAL_GAMMA", "balance": 5000000},
    {"address": "VAL_DELTA", "balance": 5000000},
    {"address": "WALLET_1", "balance": 3500000},
    {"address": "WALLET_2", "balance": 3500000},
    {"address": "WALLET_3", "balance": 3500000},
    {"address": "WALLET_4", "balance": 3500000},
    {"address": "WALLET_5", "balance": 3500000},
    {"address": "WALLET_6", "balance": 3500000}
]

const PERF_VALIDATORS = [
    {"address": "VAL_ALPHA", "stake": 400000, "pubkey": "PUB_VAL_ALPHA"},
    {"address": "VAL_BETA", "stake": 400000, "pubkey": "PUB_VAL_BETA"},
    {"address": "VAL_GAMMA", "stake": 350000, "pubkey": "PUB_VAL_GAMMA"},
    {"address": "VAL_DELTA", "stake": 350000, "pubkey": "PUB_VAL_DELTA"}
]

const PERF_WALLETS = ["WALLET_1", "WALLET_2", "WALLET_3", "WALLET_4", "WALLET_5", "WALLET_6"]

function create_performance_blockchain(max_block_txs, logging) {
    let perf_mode = PERF_TRANSACTION_COUNT >= 150
    let overrides = {
        "max_block_txs": max_block_txs,
        "base_reward": 75,
        "min_stake": 300000,
        "performance_mode": perf_mode,
        "perf_skip_validation": perf_mode,
        "perf_skip_rewards": perf_mode,
        "perf_skip_history": perf_mode
    }
    let chain = create_full_network_blockchain(overrides, PERF_GENESIS, PERF_VALIDATORS, logging)
    print("[perf] created blockchain max_txs=" + string(max_block_txs) + " validators=" + string(len(PERF_VALIDATORS)))
    return chain
}

function next_nonce(nonce_tracker, blockchain, address) {
    let candidate = nonce_tracker[address]
    if candidate == null {
        candidate = blockchain.compute_next_nonce(address)
    }
    return candidate
}

function select_recipient(index, sender_offset) {
    let target = PERF_WALLETS[(index + sender_offset) % len(PERF_WALLETS)]
    return target
}

function run_sequential_test() {
    let blockchain = create_performance_blockchain(1, false)
    let nonce_tracker = {}
    let i = 0
    let processed_blocks = 0
    let start_time = time()
    let use_fast_blocks = PERF_TRANSACTION_COUNT >= 1000

    while i < PERF_TRANSACTION_COUNT {
        let sender = PERF_WALLETS[i % len(PERF_WALLETS)]
        let recipient = select_recipient(i, 1)
        if sender == recipient {
            recipient = select_recipient(i, 2)
        }

        let amount = PERF_TRANSACTION_COUNT >= 1000 ? 100 : (50 + (i % 250))
        let fee = PERF_TRANSACTION_COUNT >= 1000 ? 1 : (5 + ((i * 3) % 25))
        let payload = PERF_TRANSACTION_COUNT >= 1000 ? "" : ("seq::" + string(i) + "::" + sender + "->" + recipient)

        let nonce = next_nonce(nonce_tracker, blockchain, sender)
        blockchain.submit_transaction_fast(sender, recipient, amount, fee, nonce, payload)
        nonce_tracker[sender] = nonce + 1

        let result = use_fast_blocks ? blockchain.produce_block_fast() : blockchain.produce_block()
        if result != false {
            processed_blocks = processed_blocks + 1
        }

        i = i + 1
    }

    let duration = time() - start_time
    let metrics = blockchain.get_chain_info()

    return {
        "duration": duration,
        "blocks": processed_blocks,
        "metrics": metrics,
        "blockchain": blockchain
    }
}

function run_sequential_batched_test() {
    let batch_block_txs = PERF_TRANSACTION_COUNT >= 1000 ? 200 : 10
    let blockchain = create_performance_blockchain(batch_block_txs, false)
    let nonce_tracker = {}
    let i = 0
    let processed_blocks = 0
    let start_time = time()

    while i < PERF_TRANSACTION_COUNT {
        let sender = PERF_WALLETS[i % len(PERF_WALLETS)]
        let recipient = select_recipient(i, 1)
        if sender == recipient {
            recipient = select_recipient(i, 2)
        }

        let amount = PERF_TRANSACTION_COUNT >= 1000 ? 100 : (50 + (i % 250))
        let fee = PERF_TRANSACTION_COUNT >= 1000 ? 1 : (5 + ((i * 3) % 25))
        let payload = PERF_TRANSACTION_COUNT >= 1000 ? "" : ("seq_batch::" + string(i) + "::" + sender + "->" + recipient)

        let nonce = next_nonce(nonce_tracker, blockchain, sender)
        blockchain.submit_transaction_fast(sender, recipient, amount, fee, nonce, payload)
        nonce_tracker[sender] = nonce + 1

        i = i + 1
    }

    processed_blocks = blockchain.produce_blocks_fast_until_empty(0)

    let duration = time() - start_time
    let metrics = blockchain.get_chain_info()

    return {
        "duration": duration,
        "blocks": processed_blocks,
        "metrics": metrics,
        "blockchain": blockchain
    }
}

function run_bulk_test() {
    let bulk_block_txs = PERF_TRANSACTION_COUNT >= 1000 ? 5000 : 75
    let blockchain = create_performance_blockchain(bulk_block_txs, false)
    let nonce_tracker = {}
    let i = 0
    let start_submission = time()
    let use_fast_blocks = PERF_TRANSACTION_COUNT >= 1000
    let use_batch_submit = false
    let use_bulk_all = PERF_TRANSACTION_COUNT >= 1000
    let bulk_from = []
    let bulk_to = []
    let bulk_amount = []
    let bulk_fee = []
    let bulk_nonce = []
    let bulk_payload = []

    while i < PERF_TRANSACTION_COUNT {
        let sender = PERF_WALLETS[i % len(PERF_WALLETS)]
        let recipient = select_recipient(i, 3)
        if sender == recipient {
            recipient = select_recipient(i, 4)
        }

        let amount = PERF_TRANSACTION_COUNT >= 1000 ? 100 : (80 + ((i * 7) % 300))
        let fee = PERF_TRANSACTION_COUNT >= 1000 ? 1 : (9 + ((i * 5) % 35))
        let payload = PERF_TRANSACTION_COUNT >= 1000 ? "" : ("bulk::" + string(i) + "::" + string(amount) + "::" + sender)

        let nonce = next_nonce(nonce_tracker, blockchain, sender)
        if use_bulk_all {
            bulk_from = append(bulk_from, sender)
            bulk_to = append(bulk_to, recipient)
            bulk_amount = append(bulk_amount, amount)
            bulk_fee = append(bulk_fee, fee)
            bulk_nonce = append(bulk_nonce, nonce)
            bulk_payload = append(bulk_payload, payload)
        } else {
            blockchain.submit_transaction_fast(sender, recipient, amount, fee, nonce, payload)
        }
        nonce_tracker[sender] = nonce + 1

        i = i + 1
    }

    let submission_time = time() - start_submission

    let start_production = time()
    let produced_blocks = 0

    if use_bulk_all {
        let bulk_result = blockchain.submit_and_produce_bulk_raw(bulk_from, bulk_to, bulk_amount, bulk_fee, bulk_nonce, bulk_payload)
        produced_blocks = bulk_result != false ? 1 : 0
    } else if use_fast_blocks {
        produced_blocks = blockchain.produce_blocks_fast_until_empty(0)
    } else {
        while true {
            let info = blockchain.get_chain_info()
            if info.pending_tx == 0 {
                break
            }

            let result = blockchain.produce_block()
            if result == false {
                break
            }
            produced_blocks = produced_blocks + 1
        }
    }

    let production_time = time() - start_production
    let metrics = blockchain.get_chain_info()
    let total_blocks = produced_blocks

    return {
        "submission_time": submission_time,
        "production_time": production_time,
        "blocks": total_blocks,
        "metrics": metrics,
        "blockchain": blockchain
    }
}

// Tune VM thresholds for performance runs
enable_vm(true)
set_vm_thresholds(1, 100000, 1)
set_vm_config({
    "use_jit": false,
    "enable_gas_metering": false,
    "use_memory_manager": true,
    "gc_threshold": 20000,
    "enable_peephole_optimizer": true,
    "enable_bytecode_optimizer": true,
    "optimizer_level": 2,
    "enable_memory_pool": true,
    "enable_async_optimizer": true,
    "enable_ssa": true,
    "enable_bytecode_converter": true,
    "enable_profiling": true,
    "profiling_level": "DETAILED",
    "profiling_sample_rate": 1.0,
    "profiling_max_samples": 2048,
    "profiling_track_overhead": false,
    "vm_full_loop": true,
    "vm_sync_all": false,
    "vm_allow_unsafe_loops": true,
    "vm_dump_bytecode": true,
    "mode": "stack"
})

// Warm up VM to ensure profiler is initialized before profiling starts
let warmup_i = 0
while warmup_i < 6 {
    warmup_i = warmup_i + 1
}

profile_start()

let sequential_single_result = run_sequential_test()
let sequential_result = run_sequential_batched_test()
let bulk_result = run_bulk_test()

profile_stop()

function compute_tps(total_tx, duration_ms) {
    if duration_ms <= 0 {
        return 0
    }
    return (total_tx * 1000) / duration_ms
}

let sequential_tps = compute_tps(PERF_TRANSACTION_COUNT, sequential_result["duration"])
let sequential_single_tps = compute_tps(PERF_TRANSACTION_COUNT, sequential_single_result["duration"])
let bulk_total_time = bulk_result["submission_time"] + bulk_result["production_time"]
let bulk_tps = compute_tps(PERF_TRANSACTION_COUNT, bulk_total_time)

print("\n===============================================")
print("ZEXUS PERFORMANCE SUMMARY :: 10K TRANSACTIONS")
print("===============================================")
print("Sequential total_ms=" + string(sequential_result["duration"]) + " | blocks=" + string(sequential_result["blocks"]) + " | avg_block_ms=" + string(sequential_result["metrics"].avg_block_ms) + " | tps=" + string(sequential_tps))
print("Sequential single-block total_ms=" + string(sequential_single_result["duration"]) + " | blocks=" + string(sequential_single_result["blocks"]) + " | avg_block_ms=" + string(sequential_single_result["metrics"].avg_block_ms) + " | tps=" + string(sequential_single_tps))
print("Bulk submission_ms=" + string(bulk_result["submission_time"]) + " | production_ms=" + string(bulk_result["production_time"]) + " | blocks=" + string(bulk_result["blocks"]) + " | avg_block_ms=" + string(bulk_result["metrics"].avg_block_ms) + " | tps=" + string(bulk_tps))
print("Pending after sequential=" + string(sequential_result["metrics"].pending_tx) + " | pending after bulk=" + string(bulk_result["metrics"].pending_tx))
print("Benchmark complete")
print("\n--- VM PROFILING REPORT ---")
print(profile_report("text", 20))
print("\n--- VM STATS ---")
print(stringify(vm_stats()))

