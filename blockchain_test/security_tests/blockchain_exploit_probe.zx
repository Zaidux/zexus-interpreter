// FULL NETWORK BLOCKCHAIN SECURITY PROBE
// Exercises adversarial scenarios against the full network blockchain

use "../full_network_chain/full_network_blockchain.zx"

let environmentPrimed = false

function ensurePrimed() {
    if environmentPrimed == false {
        run_full_network_demo(false)
        environmentPrimed = true
    }
}

function absolute(value) {
    if value < 0 {
        return value * -1
    }
    return value
}

function createSandboxChain(includeValidators, customConfig) {
    ensurePrimed()

    let chain = Blockchain()
    chain.set_logging(false)
    chain.reset_state()
    print("[TRACE] sandbox after reset validators=" + string(len(chain.validators)))
    let dbg_idx = 0
    while dbg_idx < len(chain.validators) {
        let ventry = chain.validators[dbg_idx]
        print("[TRACE] sandbox reset validator=" + string(ventry["address"]) + " stake=" + string(ventry["stake"]) + " active=" + string(ventry["active"]))
        dbg_idx = dbg_idx + 1
    }
    chain.configure(DEFAULT_FULL_NETWORK_CONFIG)
    if customConfig != null {
        chain.configure(customConfig)
    }
    chain.bootstrap(DEFAULT_FULL_NETWORK_GENESIS)

    if includeValidators == true {
        let existing_count = len(chain.validators)
        if existing_count == 0 {
            let idx = 0
            while idx < len(DEFAULT_FULL_NETWORK_VALIDATORS) {
                let validator = DEFAULT_FULL_NETWORK_VALIDATORS[idx]
                chain.register_validator(validator["address"], validator["stake"], validator["pubkey"])
                idx = idx + 1
            }
        }
    }

    return chain
}

print("============================================================")
print("  FULL NETWORK BLOCKCHAIN SECURITY / EXPLOIT PROBE")
print("============================================================")

let blocked_attacks = 0
let confirmed_findings = 0
let regression_checks = 0
let regression_failures = 0

// Attack 1: Insufficient balance double spend attempt
print("\n[Attack 1] Insufficient Balance Double Spend")
let chain1 = createSandboxChain(false, null)
let attacker = "MALICIOUS_NODE"
chain1.ensure_account(attacker)
let required_nonce_attack1 = chain1.compute_next_nonce(attacker)
try {
    chain1.submit_transaction(attacker, "ALICE_NODE", 9999999, 5, required_nonce_attack1, "attack:drain")
    print("  ❌ Attack succeeded: Balance validation failed")
    confirmed_findings = confirmed_findings + 1
} catch error {
    print("  ✅ Blocked: " + string(error))
    blocked_attacks = blocked_attacks + 1
}

// Attack 2: Nonce replay attempt
print("\n[Attack 2] Nonce Replay on ALICE_NODE")
let chain2 = createSandboxChain(false, null)
let next_nonce = chain2.compute_next_nonce("ALICE_NODE")
let replay_nonce = next_nonce - 1
if replay_nonce < 0 {
    replay_nonce = next_nonce
}
print("  Next nonce: " + string(next_nonce) + " | replaying with " + string(replay_nonce))
try {
    chain2.submit_transaction("ALICE_NODE", "CHARLIE_NODE", 500, 5, replay_nonce, "attack:replay")
    print("  ❌ Attack succeeded: Nonce replay accepted")
    confirmed_findings = confirmed_findings + 1
} catch error {
    print("  ✅ Blocked: " + string(error))
    blocked_attacks = blocked_attacks + 1
}

// Attack 3: Duplicate validator registration
print("\n[Attack 3] Duplicate Validator Registration")
let chain3 = createSandboxChain(false, null)
// Pre-register the validator if not already set up
try {
    chain3.register_validator("ALICE_NODE", 30000, "PUB_ALICE_01")
} catch ignore {}

let duplicate_blocked = false
try {
    chain3.register_validator("ALICE_NODE", 25000, "PUB_ALICE_DUP")
    print("  ❌ Attack succeeded: Duplicate validator allowed")
    confirmed_findings = confirmed_findings + 1
} catch error {
    print("  ✅ Blocked: " + string(error))
    duplicate_blocked = true
}

if duplicate_blocked {
    blocked_attacks = blocked_attacks + 1
}

// Attack 4: Direct state mutation attempt
print("\n[Attack 4] Direct Balance Mutation from Host Context")
let chain4 = createSandboxChain(false, null)
let balance_before = chain4.get_balance("ALICE_NODE")
let mutation_applied = false
let mutation_error = null
try {
    chain4.balances["ALICE_NODE"] = 1
    mutation_applied = true
} catch error {
    mutation_error = error
}

if mutation_applied {
    let detection_error = null
    let balance_after = balance_before
    try {
        balance_after = chain4.get_balance("ALICE_NODE")
    } catch error {
        detection_error = error
    }

    if detection_error != null {
        print("  [Attack 4] ✅ Blocked (mutation detected): " + string(detection_error))
        blocked_attacks = blocked_attacks + 1
    } else if balance_after != balance_before {
        print("  [Attack 4] ⚠️  Vulnerable: Balance changed from " + string(balance_before) + " to " + string(balance_after))
        confirmed_findings = confirmed_findings + 1
    } else {
        print("  [Attack 4] ✅ Blocked (mutation ineffective)")
        blocked_attacks = blocked_attacks + 1
    }
} else {
    print("  [Attack 4] ✅ Blocked (mutation attempt failed): " + string(mutation_error))
    blocked_attacks = blocked_attacks + 1
}

// Attack 5: Post-block nonce reuse attempt
print("\n[Attack 5] Post-Block Nonce Reuse")
let chain5 = createSandboxChain(false, null)
// Ensure validators exist for block production
if len(chain5.validators) == 0 {
    try { chain5.register_validator("ALICE_NODE", 30000, "PUB_A5") } catch ignore {}
    try { chain5.register_validator("BOB_NODE", 30000, "PUB_B5") } catch ignore {}
    try { chain5.register_validator("DARIA_NODE", 25000, "PUB_D5") } catch ignore {}
}

let source_account = "ALICE_NODE"
let legitimate_nonce = chain5.compute_next_nonce(source_account)
chain5.submit_transaction(source_account, "CHARLIE_NODE", 600, 15, legitimate_nonce, "flow:legit-tx")
chain5.produce_block()

let reuse_nonce = legitimate_nonce
try {
    chain5.submit_transaction(source_account, "ELLA_NODE", 450, 10, reuse_nonce, "attack:reuse-post-block")
    print("  ❌ Attack succeeded: Post-block nonce reuse accepted")
    confirmed_findings = confirmed_findings + 1
} catch error {
    print("  [Attack 5] ✅ Blocked (post-block reuse): " + string(error))
    blocked_attacks = blocked_attacks + 1
}

// Regression 1: Consensus threshold overshoot triggers rollback and slash
print("\n[Regression] Consensus Threshold Overshoot -> Rollback & Slash")
let regression_config_fail = {
    "consensus_threshold_bp": 15000,
    "validator_slash_penalty_bp": 500
}
let chain_reg1 = createSandboxChain(true, regression_config_fail)
let nonce_reg1 = chain_reg1.compute_next_nonce("ALICE_NODE")
chain_reg1.submit_transaction("ALICE_NODE", "BOB_NODE", 800, 25, nonce_reg1, "reg:threshold-overshoot")
let rejection = chain_reg1.produce_block()
regression_checks = regression_checks + 1
if rejection == false {
    print("  ❌ Regression failure: produce_block returned false")
    regression_failures = regression_failures + 1
} else {
    print("  [TRACE] rejection height=" + string(rejection["height"]) + " proposer=" + string(rejection["proposer"]) + " consensus=" + string(rejection["consensus"]))
    print("  [TRACE] rejection ratio=" + string(rejection["consensus_ratio_bp"]) + "bp threshold=" + string(rejection["threshold_bp"]) + "bp slash=" + string(rejection["slash_amount"]))
    let audit_state = chain_reg1.get_chain_info()
    let audit_snapshot = audit_state["audit"]
    let storage_tail = chain_reg1.get_storage_commitments(1)
    print("  [TRACE] post_slash_stake_api=" + string(chain_reg1.get_stake(rejection["proposer"])))
    if audit_snapshot != null {
        let rollbacks = audit_snapshot["storage_rollbacks"]
        let slash_events = audit_snapshot["slash_events"]
        let treasury_total = audit_state["treasury_balance"]
        print("  [TRACE] audit_snapshot rollbacks=" + string(rollbacks) + " slash_events=" + string(slash_events) + " treasury=" + string(treasury_total))
    } else {
        print("  [TRACE] audit_snapshot missing")
    }
    print("  [TRACE] storage checkpoints=" + string(len(storage_tail)))
    let latest_entry = null
    if len(storage_tail) > 0 {
        latest_entry = storage_tail[len(storage_tail) - 1]
    }
    let proposer_after = null
    let idx_reg1 = 0
    while idx_reg1 < len(chain_reg1.validators) {
        let validator = chain_reg1.validators[idx_reg1]
        if validator["address"] == rejection["proposer"] {
            proposer_after = validator
            break
        }
        idx_reg1 = idx_reg1 + 1
    }

    let ratio_check = true
    if rejection["consensus_ratio_bp"] != null && rejection["threshold_bp"] != null {
        ratio_check = rejection["consensus_ratio_bp"] < rejection["threshold_bp"]
    }

    let rollback_ok = (rejection["consensus"] == "rejected")
    rollback_ok = rollback_ok && ratio_check
    rollback_ok = rollback_ok && (rejection["slash_amount"] > 0)
    if audit_snapshot != null {
        rollback_ok = rollback_ok && (audit_snapshot["storage_rollbacks"] > 0)
        rollback_ok = rollback_ok && (audit_snapshot["slash_events"] > 0)
    } else {
        rollback_ok = false
    }
    if audit_state["treasury_balance"] != null {
        rollback_ok = rollback_ok && (audit_state["treasury_balance"] >= rejection["slash_amount"])
    }
    if latest_entry != null {
        rollback_ok = rollback_ok && (latest_entry["trigger"] == "rollback")
    } else {
        rollback_ok = false
    }
    if proposer_after != null {
        rollback_ok = rollback_ok && (proposer_after["stake"] < 30000)
        print("  [TRACE] proposer_after stake=" + string(proposer_after["stake"]) + " active=" + string(proposer_after["active"]))
    } else {
        print("  [TRACE] proposer_after missing")
    }

    if rollback_ok {
        print("  ✅ Rollback enforced. Ratio=" + string(rejection["consensus_ratio_bp"]) + "bp vs threshold=" + string(rejection["threshold_bp"]) + "bp")
        print("     Slash=" + string(rejection["slash_amount"]) + " treasury=" + string(audit_state["treasury_balance"]))
        if latest_entry != null {
            print("     Storage checkpoint -> trigger=" + string(latest_entry["trigger"]) + " root=" + string(latest_entry["root"]))
        }
    } else {
        print("  ❌ Regression failure: Rollback or slashing safeguards missing")
        regression_failures = regression_failures + 1
    }
}

// Regression 2: Reward distribution split validation
print("\n[Regression] Reward Distribution Split Audit")
let reward_config = {
    "treasury_rate_bp": 1000,
    "proposer_commission_bp": 7200,
    "participation_rate_bp": 2200,
    "consensus_threshold_bp": 6600
}
let chain_reg2 = createSandboxChain(true, reward_config)
let nonce_reg2a = chain_reg2.compute_next_nonce("ALICE_NODE")
chain_reg2.submit_transaction("ALICE_NODE", "CHARLIE_NODE", 1200, 40, nonce_reg2a, "reg:reward-alpha")
let nonce_reg2b = chain_reg2.compute_next_nonce("BOB_NODE")
chain_reg2.submit_transaction("BOB_NODE", "DARIA_NODE", 900, 30, nonce_reg2b, "reg:reward-beta")
let reward_block = chain_reg2.produce_block()
regression_checks = regression_checks + 1
if reward_block == false {
    print("  ❌ Regression failure: Reward block not produced")
    regression_failures = regression_failures + 1
} else if reward_block["consensus"] != "committed" {
    print("  ❌ Regression failure: Unexpected consensus state -> " + string(reward_block["consensus"]))
    regression_failures = regression_failures + 1
} else {
    let distributed_total = reward_block["proposer_reward"] + reward_block["participant_paid"] + reward_block["treasury_accrual"]
    let reward_diff = absolute(reward_block["reward"] - distributed_total)
    let info_reward = chain_reg2.get_chain_info()
    let audit_reward = info_reward["audit"]
    let treasury_diff = absolute(info_reward["treasury_balance"] - reward_block["treasury_accrual"])
    let expected_fees = 70
    let fee_diff = expected_fees
    if audit_reward != null {
        fee_diff = absolute(audit_reward["fee_accumulator"] - expected_fees)
    }
    let storage_entries = chain_reg2.get_storage_commitments(2)
    let latest_commit = null
    if len(storage_entries) > 0 {
        latest_commit = storage_entries[len(storage_entries) - 1]
    }
    let latest_meta = null
    if latest_commit != null {
        latest_meta = latest_commit["metadata"]
    }

    let tolerance = 1
    let payout_ok = (reward_diff <= tolerance)
    payout_ok = payout_ok && (treasury_diff <= tolerance)
    payout_ok = payout_ok && (fee_diff <= tolerance)
    if latest_commit != null {
        payout_ok = payout_ok && (latest_commit["trigger"] == "block_commit")
    } else {
        payout_ok = false
    }
    if latest_meta != null {
        payout_ok = payout_ok && (latest_meta["ratio_bp"] == reward_block["consensus_ratio_bp"])
    }
    if audit_reward != null {
        payout_ok = payout_ok && (audit_reward["participant_rewards"] >= reward_block["participant_paid"])
        payout_ok = payout_ok && (audit_reward["treasury_accruals"] >= reward_block["treasury_accrual"])
    }
    payout_ok = payout_ok && (reward_block["participant_paid"] > 0)
    if reward_block["consensus_ratio_bp"] != null && reward_block["threshold_bp"] != null {
        payout_ok = payout_ok && (reward_block["consensus_ratio_bp"] >= reward_block["threshold_bp"])
    }

    if payout_ok {
        print("  ✅ Reward split balanced. Proposer=" + string(reward_block["proposer_reward"]) + " Participant=" + string(reward_block["participant_paid"]) + " Treasury=" + string(reward_block["treasury_accrual"]))
        print("     Ratio=" + string(reward_block["consensus_ratio_bp"]) + "bp threshold=" + string(reward_block["threshold_bp"]) + "bp")
        if latest_commit != null {
            print("     Storage checkpoint -> trigger=" + string(latest_commit["trigger"]) + " root=" + string(latest_commit["root"]))
            if latest_meta != null {
                print("     Metadata ratio=" + string(latest_meta["ratio_bp"]))
            }
        }
        if audit_reward != null {
            print("     Fee accumulator=" + string(audit_reward["fee_accumulator"]) + " | Treasury=" + string(info_reward["treasury_balance"]))
        }
    } else {
        print("  ❌ Regression failure: Reward or storage metrics mismatched")
        regression_failures = regression_failures + 1
    }
}

print("\n[Performance] High-Volume Throughput & Replay Guard")
let perf_config = {
    "max_block_txs": 8,
    "consensus_threshold_bp": 6400
}
let chain_perf = createSandboxChain(true, perf_config)
let perf_accounts = ["ALICE_NODE", "BOB_NODE", "CHARLIE_NODE", "DARIA_NODE"]
let perf_idx = 0
while perf_idx < len(perf_accounts) {
    chain_perf.ensure_account(perf_accounts[perf_idx])
    perf_idx = perf_idx + 1
}

let perf_loop = 0
while perf_loop < 12 {
    let sender_idx = perf_loop % len(perf_accounts)
    let recipient_idx = (perf_loop + 1) % len(perf_accounts)
    let sender_addr = perf_accounts[sender_idx]
    let recipient_addr = perf_accounts[recipient_idx]
    let perf_nonce = chain_perf.compute_next_nonce(sender_addr)
    chain_perf.submit_transaction(sender_addr, recipient_addr, 120 + perf_loop, 6, perf_nonce, "perf:loop-" + string(perf_loop))
    perf_loop = perf_loop + 1
}

let perf_block = chain_perf.produce_block()
regression_checks = regression_checks + 1
if perf_block == false {
    print("  ❌ Performance regression: Block production stalled")
    regression_failures = regression_failures + 1
} else if perf_block["consensus"] != "committed" {
    print("  ❌ Performance regression: Unexpected consensus state -> " + string(perf_block["consensus"]))
    regression_failures = regression_failures + 1
} else {
    let elapsed_perf = perf_block["elapsed_ms"]
    let perf_info = chain_perf.get_chain_info()
    let perf_audit = perf_info["audit"]
    let perf_commitments = chain_perf.get_storage_commitments(1)
    let timing_ok = elapsed_perf <= 250
    let rollback_safe = true
    if perf_audit != null {
        rollback_safe = perf_audit["storage_rollbacks"] == 0
    }
    let checkpoint_ok = len(perf_commitments) > 0

    let reuse_sender = perf_accounts[0]
    let replay_nonce = chain_perf.compute_next_nonce(reuse_sender) - 1
    if replay_nonce < 0 {
        replay_nonce = 0
    }
    let replay_blocked = false
    try {
        chain_perf.submit_transaction(reuse_sender, perf_accounts[1], 50, 5, replay_nonce, "perf:replay")
    } catch error {
        replay_blocked = true
        print("  [TRACE] replay guard triggered=" + string(error))
    }

    if timing_ok && rollback_safe && checkpoint_ok && replay_blocked {
        print("  ✅ Performance block committed in " + string(elapsed_perf) + " ms with replay guard active")
        if perf_audit != null {
            print("     Audit metrics -> fee_accumulator=" + string(perf_audit["fee_accumulator"]) + " rollbacks=" + string(perf_audit["storage_rollbacks"]))
        }
        print("     Storage checkpoints observed=" + string(len(perf_commitments)))
    } else {
        print("  ❌ Performance regression: Safeguard failure detected")
        regression_failures = regression_failures + 1
    }
}

print("\n============================================================")
print("Summary")
print("  Blocked attacks: " + string(blocked_attacks))
print("  Confirmed findings: " + string(confirmed_findings))
print("  Regression checks: " + string(regression_checks) + " (failures=" + string(regression_failures) + ")")
if confirmed_findings > 0 {
    print("  ⚠️  Review required: See findings above.")
} else {
    print("  ✅ No exploitable issues detected by probes.")
}
if regression_failures > 0 {
    print("  ⚠️  Regression safeguards reported issues above.")
} else {
    print("  ✅ Regression safeguards verified.")
}
print("============================================================")
