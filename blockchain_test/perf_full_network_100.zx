// Zexus performance benchmark: 100 transactions sequential vs bulk
// Lightweight variant of perf_full_network_10k for faster iteration

use "./full_network_chain/full_network_blockchain.zx"

const PERF_TRANSACTION_COUNT = 100

const PERF_GENESIS = [
    {"address": "VAL_ALPHA", "balance": 5000000},
    {"address": "VAL_BETA", "balance": 5000000},
    {"address": "VAL_GAMMA", "balance": 5000000},
    {"address": "VAL_DELTA", "balance": 5000000},
    {"address": "WALLET_1", "balance": 3500000},
    {"address": "WALLET_2", "balance": 3500000},
    {"address": "WALLET_3", "balance": 3500000},
    {"address": "WALLET_4", "balance": 3500000},
    {"address": "WALLET_5", "balance": 3500000},
    {"address": "WALLET_6", "balance": 3500000}
]

const PERF_VALIDATORS = [
    {"address": "VAL_ALPHA", "stake": 400000, "pubkey": "PUB_VAL_ALPHA"},
    {"address": "VAL_BETA", "stake": 400000, "pubkey": "PUB_VAL_BETA"},
    {"address": "VAL_GAMMA", "stake": 350000, "pubkey": "PUB_VAL_GAMMA"},
    {"address": "VAL_DELTA", "stake": 350000, "pubkey": "PUB_VAL_DELTA"}
]

const PERF_WALLETS = ["WALLET_1", "WALLET_2", "WALLET_3", "WALLET_4", "WALLET_5", "WALLET_6"]

function create_performance_blockchain(max_block_txs, logging) {
    let perf_mode = PERF_TRANSACTION_COUNT >= 150
    let overrides = {
        "max_block_txs": max_block_txs,
        "base_reward": 75,
        "min_stake": 300000,
        "performance_mode": perf_mode
    }
    let chain = create_full_network_blockchain(overrides, PERF_GENESIS, PERF_VALIDATORS, logging)
    print("[perf] created blockchain max_txs=" + string(max_block_txs) + " validators=" + string(len(PERF_VALIDATORS)))
    return chain
}

function next_nonce(nonce_tracker, blockchain, address) {
    let candidate = nonce_tracker[address]
    if candidate == null {
        candidate = blockchain.compute_next_nonce(address)
    }
    return candidate
}

function select_recipient(index, sender_offset) {
    let target = PERF_WALLETS[(index + sender_offset) % len(PERF_WALLETS)]
    return target
}

function run_sequential_test() {
    let blockchain = create_performance_blockchain(1, false)
    let nonce_tracker = {}
    let i = 0
    let processed_blocks = 0
    let start_time = time()
    let use_fast_blocks = PERF_TRANSACTION_COUNT >= 1000

    while i < PERF_TRANSACTION_COUNT {
        let sender = PERF_WALLETS[i % len(PERF_WALLETS)]
        let recipient = select_recipient(i, 1)
        if sender == recipient {
            recipient = select_recipient(i, 2)
        }

        let amount = 50 + (i % 250)
        let fee = 5 + ((i * 3) % 25)
        let payload = "seq::" + string(i) + "::" + sender + "->" + recipient

        let nonce = next_nonce(nonce_tracker, blockchain, sender)
        blockchain.submit_transaction_fast(sender, recipient, amount, fee, nonce, payload)
        nonce_tracker[sender] = nonce + 1

        let result = use_fast_blocks ? blockchain.produce_block_fast() : blockchain.produce_block()
        if result != false {
            processed_blocks = processed_blocks + 1
        }

        i = i + 1
    }

    let duration = time() - start_time
    let metrics = blockchain.get_chain_info()

    return {
        "duration": duration,
        "blocks": processed_blocks,
        "metrics": metrics,
        "blockchain": blockchain
    }
}

function run_bulk_test() {
    let bulk_block_txs = PERF_TRANSACTION_COUNT >= 1000 ? 5000 : 75
    let blockchain = create_performance_blockchain(bulk_block_txs, false)
    let nonce_tracker = {}
    let i = 0
    let start_submission = time()
    let use_fast_blocks = PERF_TRANSACTION_COUNT >= 1000
    let use_batch_submit = PERF_TRANSACTION_COUNT >= 1000
    let batch = []
    let batch_size = 200
    let use_bulk_all = PERF_TRANSACTION_COUNT >= 1000

    while i < PERF_TRANSACTION_COUNT {
        let sender = PERF_WALLETS[i % len(PERF_WALLETS)]
        let recipient = select_recipient(i, 3)
        if sender == recipient {
            recipient = select_recipient(i, 4)
        }

        let amount = 80 + ((i * 7) % 300)
        let fee = 9 + ((i * 5) % 35)
        let payload = "bulk::" + string(i) + "::" + string(amount) + "::" + sender

        let nonce = next_nonce(nonce_tracker, blockchain, sender)
        if use_batch_submit {
            batch = append(batch, {
                "from": sender,
                "to": recipient,
                "amount": amount,
                "fee": fee,
                "nonce": nonce,
                "payload": payload
            })
        } else {
            blockchain.submit_transaction_fast(sender, recipient, amount, fee, nonce, payload)
        }
        nonce_tracker[sender] = nonce + 1

        if use_batch_submit && len(batch) >= batch_size {
            blockchain.submit_transactions_batch(batch)
            batch = []
        }

        i = i + 1
    }

    let submission_time = time() - start_submission

    if use_batch_submit && len(batch) > 0 {
        blockchain.submit_transactions_batch(batch)
    }

    let start_production = time()
    let produced_blocks = 0

    if use_bulk_all {
        produced_blocks = 0
        let bulk_result = blockchain.produce_block_bulk_all()
        if bulk_result != false {
            produced_blocks = 1
        }
    } else if use_fast_blocks {
        produced_blocks = blockchain.produce_blocks_fast_until_empty(0)
    } else {
        while true {
            let info = blockchain.get_chain_info()
            if info.pending_tx == 0 {
                break
            }

            let result = blockchain.produce_block()
            if result == false {
                break
            }
            produced_blocks = produced_blocks + 1
        }
    }

    let production_time = time() - start_production
    let metrics = blockchain.get_chain_info()
    let total_blocks = produced_blocks

    return {
        "submission_time": submission_time,
        "production_time": production_time,
        "blocks": total_blocks,
        "metrics": metrics,
        "blockchain": blockchain
    }
}

let sequential_result = run_sequential_test()
let bulk_result = run_bulk_test()

function compute_tps(total_tx, duration_ms) {
    if duration_ms <= 0 {
        return 0
    }
    return (total_tx * 1000) / duration_ms
}

let sequential_tps = compute_tps(PERF_TRANSACTION_COUNT, sequential_result["duration"])
let bulk_total_time = bulk_result["submission_time"] + bulk_result["production_time"]
let bulk_tps = compute_tps(PERF_TRANSACTION_COUNT, bulk_total_time)

print("\n===============================================")
print("ZEXUS PERFORMANCE SUMMARY :: 100 TRANSACTIONS")
print("===============================================")
print("Sequential total_ms=" + string(sequential_result["duration"]) + " | blocks=" + string(sequential_result["blocks"]) + " | avg_block_ms=" + string(sequential_result["metrics"].avg_block_ms) + " | tps=" + string(sequential_tps))
print("Bulk submission_ms=" + string(bulk_result["submission_time"]) + " | production_ms=" + string(bulk_result["production_time"]) + " | blocks=" + string(bulk_result["blocks"]) + " | avg_block_ms=" + string(bulk_result["metrics"].avg_block_ms) + " | tps=" + string(bulk_tps))
print("Pending after sequential=" + string(sequential_result["metrics"].pending_tx) + " | pending after bulk=" + string(bulk_result["metrics"].pending_tx))
print("Benchmark complete for 100 transactions")
