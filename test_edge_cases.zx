// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ZEXUS 1.6.7 - COMPREHENSIVE EDGE CASE TEST SUITE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let test_count = 0;
let pass_count = 0;
let fail_count = 0;

action test(name, condition) {
    test_count = test_count + 1;
    if condition {
        print("âœ… PASS: " + name);
        pass_count = pass_count + 1;
    } else {
        print("âŒ FAIL: " + name);
        fail_count = fail_count + 1;
    }
}

print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
print("â•‘      ZEXUS 1.6.7 - EDGE CASE TEST SUITE                 â•‘");
print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
print("");

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 1: Deeply Nested Map Access (3+ levels)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("â”â”â” TEST 1: Deeply Nested Maps (3+ levels) â”â”â”");

let deep = {
    "level1": {
        "level2": {
            "level3": {
                "value": 42
            }
        }
    }
};

deep["level1"]["level2"]["level3"]["value"] = 100;
test("Deep nested map assignment", deep["level1"]["level2"]["level3"]["value"] == 100);

deep["level1"]["level2"]["level3"]["value"] += 50;
test("Deep nested compound assignment", deep["level1"]["level2"]["level3"]["value"] == 150);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 2: Mixed Statement Types in Blocks
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 2: Mixed Statement Types â”â”â”");

let mixed_result = 0;
{
    let temp = 10;
    print("Inside block");
    temp = temp + 5;
    mixed_result = temp;
}
test("Let + print + assignment in block", mixed_result == 15);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 3: Conditionals with Nested Assignments
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 3: Conditionals with Assignments â”â”â”");

let config = {"mode": "test", "count": 0};
if config["mode"] == "test" {
    config["count"] = 5;
    config["status"] = "active";
}
test("If block with multiple assignments", config["count"] == 5 && config["status"] == "active");

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 4: Loops with Compound Assignments
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 4: Loops with Compound Assignments â”â”â”");

let counter = {"value": 0, "iterations": 0};
let i = 0;
while i < 3 {
    counter["value"] += 10;
    counter["iterations"] += 1;
    i = i + 1;
}
test("While loop with nested compound assignments", counter["value"] == 30 && counter["iterations"] == 3);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 5: Contract with Multiple State Variables
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 5: Contract with Many State Variables â”â”â”");

contract MultiState {
    state users = {};
    state settings = {};
    state logs = {};
    state counter = 0;
    
    action init() {
        settings["initialized"] = true;
        counter = 1;
    }
    
    action add_user(name, age) {
        users[name] = {"age": age, "active": true};
        counter += 1;
        logs[name] = "created";
    }
    
    action update_user(name) {
        users[name]["active"] = false;
        logs[name] = "deactivated";
        counter += 1;
    }
    
    action get_state() {
        return {"users": users, "counter": counter, "logs": logs};
    }
}

let ms = MultiState();
ms.init();
ms.add_user("alice", 25);
ms.add_user("bob", 30);
ms.update_user("alice");
let contract_result = ms.get_state();  // Changed from 'state' to 'contract_result'
test("Contract multiple state vars", contract_result["counter"] == 4);
test("Contract nested state operations", contract_result["users"]["alice"]["active"] == false);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 6: Chained Method Calls
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 6: Method Chaining â”â”â”");

contract Chain {
    state value = 0;
    
    action add(n) {
        value += n;
        return this;
    }
    
    action multiply(n) {
        value *= n;
        return this;
    }
    
    action get() {
        return value;
    }
}

let chain = Chain();
chain.add(5);
chain.multiply(3);
let chain_result = chain.get();
test("Sequential method calls", chain_result == 15);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 7: Complex Expressions with Operator Precedence
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 7: Complex Expressions â”â”â”");

let calc = {"a": 10, "b": 5, "c": 2};
calc["result"] = calc["a"] + calc["b"] * calc["c"];
test("Operator precedence in assignment", calc["result"] == 20);

calc["result"] = (calc["a"] + calc["b"]) * calc["c"];
test("Parentheses override precedence", calc["result"] == 30);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 8: Multiple Assignments in Contract Actions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 8: Multiple Print + Assignment in Contract â”â”â”");

contract Sequencer {
    state count = 0;
    state status = "init";
    
    action process() {
        print("Step 1");
        count = 1;
        print("Step 2");
        count += 1;
        print("Step 3");
        status = "processing";
        print("Step 4");
        count += 1;
        print("Step 5");
        status = "done";
        return count;
    }
    
    action get_status() {
        return status;
    }
}

let seq = Sequencer();
let final_count = seq.process();
let final_status = seq.get_status();
test("Multiple prints with assignments", final_count == 3 && final_status == "done");

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 9: Map Reconstruction with Spread-like Pattern
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 9: Complex Map Reconstruction â”â”â”");

let original = {"a": 1, "b": 2, "c": 3};
let updated = {"a": original["a"], "b": original["b"] + 10, "c": original["c"], "d": 4};
test("Map reconstruction with modifications", updated["b"] == 12 && updated["d"] == 4);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 10: Multiple Contract Instances Sharing Data
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 10: Multiple Contract Instances â”â”â”");

contract Counter {
    state value = 0;
    
    action increment() {
        value += 1;
    }
    
    action get() {
        return value;
    }
}

let counter1 = Counter();
let counter2 = Counter();
counter1.increment();
counter1.increment();
counter2.increment();
let result1 = counter1.get();
let result2 = counter2.get();
test("Multiple contract instances isolated", result1 == 2 && result2 == 1);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 11: Try-Catch with Assignments
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 11: Try-Catch Error Handling â”â”â”");

let error_state = {"caught": false, "value": 0};
try {
    error_state["value"] = 10;
    error_state["caught"] = false;
} catch e {
    error_state["caught"] = true;
}
test("Try block with assignments", error_state["value"] == 10 && error_state["caught"] == false);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 12: Return Statements with Complex Expressions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 12: Complex Return Statements â”â”â”");

action complex_return(data) {
    let temp = {"result": data["x"] + data["y"]};
    temp["doubled"] = temp["result"] * 2;
    return temp;
}

let ret = complex_return({"x": 5, "y": 3});
test("Complex return with local assignments", ret["result"] == 8 && ret["doubled"] == 16);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 13: Array-like Access Patterns
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 13: Array-like Map Operations â”â”â”");

let arr = {};
arr["0"] = "first";
arr["1"] = "second";
arr["2"] = "third";
arr["length"] = 3;

arr["1"] = "UPDATED";
arr["length"] += 1;
arr["3"] = "fourth";

test("Array-like map updates", arr["1"] == "UPDATED" && arr["length"] == 4);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 14: Multiple Compound Operators in Sequence
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 14: Compound Operator Sequences â”â”â”");

let ops = {"a": 100, "b": 10, "c": 2};
ops["a"] -= 50;  // 50
ops["b"] *= 3;   // 30
ops["c"] += 8;   // 10
let sum = ops["a"] + ops["b"] + ops["c"];
test("Multiple different compound ops", sum == 90);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST 15: Conditional Assignment Expressions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â”â”â” TEST 15: Conditional Assignments â”â”â”");

let cond = {"flag": true, "result": 0};
cond["result"] = cond["flag"] ? 100 : 50;
test("Ternary in assignment", cond["result"] == 100);

cond["flag"] = false;
cond["result"] = cond["flag"] ? 100 : 50;
test("Ternary with false condition", cond["result"] == 50);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FINAL RESULTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("");
print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
print("â•‘                    FINAL RESULTS                         â•‘");
print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
print("");
print("  Total Tests: " + string(test_count));
print("  Passed: " + string(pass_count));
print("  Failed: " + string(fail_count));
print("");

if fail_count == 0 {
    print("  ğŸ‰ ALL EDGE CASES PASSED!");
    print("  âœ¨ Zexus is handling complex patterns correctly!");
} else {
    print("  âš ï¸  Some edge cases need attention");
    print("  Success rate: " + string(pass_count * 100 / test_count) + "%");
}

print("");
print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
